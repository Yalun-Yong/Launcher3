/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.launcher3;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.SystemClock;
import android.support.v4.widget.AutoScrollHelper;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ActionMode;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

import com.android.launcher3.Folder.MyAdapter.ViewHolder;
import com.android.launcher3.FolderInfo.FolderListener;
import com.android.launcher3.LauncherModel.Callbacks;
import com.android.launcher3.LauncherSettings.Favorites;
import com.android.launcher3.MuchFolderPageView.MuchPagedViewChangeListener;
import com.android.launcher3.MuchFolderPageView.MyPagerAdapter;
import com.android.launcher3.much.MuchConfig;
import com.android.launcher3.much.MuchFolderPagedViewIndicator;
import com.android.launcher3.much.folder.addapp.MuchDraggableGridViewPager;
import com.android.launcher3.much.folder.addapp.MuchDraggableGridViewPager.OnPageChangeListener;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource, View.OnClickListener,
        View.OnLongClickListener, DropTarget, FolderListener, TextView.OnEditorActionListener,
        View.OnFocusChangeListener {
    private static final String TAG = "Launcher.Folder";

    protected DragController mDragController;
    protected Launcher mLauncher;
    protected FolderInfo mInfo;

    static final int STATE_NONE = -1;
    static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;

    private int mExpandDuration;
//    protected CellLayout mContent;
    private ScrollView mScrollView;
    protected MuchFolderCellLayout mCellLayout;
    protected MuchFolderPageView mContent;
    private MuchPagedViewChangeListener mPageChangeListener;
    private MyPagerAdapter mPageAdapter;
    private MuchFolderPagedViewIndicator mViewPageIndicator;
    private int mIndicatorHeight;
    private ObjectAnimator mOpenCloseAnimator;
    private int mStatusBarHeigth = 0;
    private final static int CELL_COUNT_X = 4;
    private final static int CELL_COUNT_Y = 3;
    private LinearLayout mFolderFrame;
    private final LayoutInflater mInflater;
    private final IconCache mIconCache;
    private int mState = STATE_NONE;
    private static final int REORDER_ANIMATION_DURATION = 230;
    private static final int REORDER_DELAY = 250;
    private static final int ON_EXIT_CLOSE_DELAY = 800;
    private boolean mRearrangeOnClose = false;
    private FolderIcon mFolderIcon;
    private int mMaxCountX;
    private int mMaxCountY;
    private int mMaxNumItems;
    private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
    private Drawable mIconDrawable;
    boolean mItemsInvalidated = false;
    private ShortcutInfo mCurrentDragInfo;
    private View mCurrentDragView;
    boolean mSuppressOnAdd = false;
    private int[] mTargetCell = new int[2];
    private int[] mPreviousTargetCell = new int[2];
    private int[] mEmptyCell = new int[2];
    private Alarm mReorderAlarm = new Alarm();
    private Alarm mOnExitAlarm = new Alarm();
    private int mFolderNameHeight;
    private Rect mTempRect = new Rect();
    private boolean mDragInProgress = false;
    private boolean mDeleteFolderOnDropCompleted = false;
    private boolean mSuppressFolderDeletion = false;
    private boolean mItemAddedBackToSelfViaIcon = false;
    FolderEditText mFolderName;
    private float mFolderIconPivotX;
    private float mFolderIconPivotY;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private static String sDefaultFolderName;
    private static String sHintText;

    private int DRAG_MODE_NONE = 0;
    private int DRAG_MODE_REORDER = 1;
    private int mDragMode = DRAG_MODE_NONE;

    private boolean mDestroyed;

    private AutoScrollHelper mAutoScrollHelper;  //modify by linmaoqing 2014-5-13

    private Runnable mDeferredAction;
    private boolean mDeferDropAfterUninstall;
    private boolean mUninstallSuccessful;
    private static final int FOLDER_MIN_APP = 2;//文件夹中最少应用数

    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);

        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        setAlwaysDrawnWithCacheEnabled(false);
        mInflater = LayoutInflater.from(context);
        mIconCache = app.getIconCache();

        Resources res = getResources();
        mMaxCountX = (int) grid.numColumns;
        mMaxCountY = (int) grid.numRows;
        mMaxNumItems = mMaxCountX * mMaxCountY;
        if(MuchConfig.SUPPORT_MUCH_STYLE) {
            mMaxNumItems = CELL_COUNT_X * CELL_COUNT_Y;
        }
        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

        mExpandDuration = res.getInteger(R.integer.config_folderAnimDuration);

        if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }
        if (sHintText == null) {
            sHintText = res.getString(R.string.folder_hint_text);
        }
        mLauncher = (Launcher) context;
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        //add by linmaoqing 2014-5-12
        if(MuchConfig.SUPPORT_MUCH_STYLE){
            mFolderFrame = (LinearLayout)findViewById(R.id.folder_frame);
            mCellLayout = (MuchFolderCellLayout)mInflater.inflate(R.layout.much_folder_screen, null);
            mContent = (MuchFolderPageView) findViewById(R.id.folder_page);
            mContent.setLayoutInflater(mInflater);
            mPageAdapter = mContent.new MyPagerAdapter(mCellLayout);
            mContent.setAdapter(mPageAdapter);
            mPageChangeListener = mContent.new MuchPagedViewChangeListener();
            mContent.setOnPageChangeListener(mPageChangeListener);
            mViewPageIndicator = (MuchFolderPagedViewIndicator)findViewById(R.id.folder_indicator);
            mContent.addFolderViewPageListener(mViewPageIndicator);
            mIndicatorHeight = mViewPageIndicator.getMaxHeigh();
        }else{
            mScrollView = (ScrollView) findViewById(R.id.scroll_view);
//        mContent = (CellLayout) findViewById(R.id.folder_content);
        }
        //end by linmaoqing
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();

        mContent.setCellDimensions(grid.folderCellWidthPx, grid.folderCellHeightPx);
        mContent.setGridSize(0, 0);
        mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
        if(MuchConfig.SUPPORT_MUCH_STYLE) {
            mContent.setGridSize(CELL_COUNT_X, CELL_COUNT_Y);
        } else {
            mContent.setGridSize(0, 0);
        }
        if(MuchConfig.SUPPORT_MUCH_STYLE){
            setAllContainersMotionEventSplittingEnabled(false);
        }else{
            mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
        }
        mContent.setInvertIfRtl(true);
        mFolderName = (FolderEditText) findViewById(R.id.folder_name);
        mFolderName.setFolder(this);
        mFolderName.setOnFocusChangeListener(this);

        // We find out how tall the text view wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        int measureSpec = MeasureSpec.UNSPECIFIED;
        mFolderName.measure(measureSpec, measureSpec);
        mFolderNameHeight = mFolderName.getMeasuredHeight();

        // We disable action mode for now since it messes up the view on phones
        mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
        mFolderName.setOnEditorActionListener(this);
        if(!MuchConfig.SUPPORT_MUCH_STYLE) {
            mFolderName.setSelectAllOnFocus(true);
        }
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        if(!MuchConfig.SUPPORT_MUCH_STYLE){
            mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);  //modify by linmaoqing 2014-5-13
        }
    }

    private void setAllContainersMotionEventSplittingEnabled(boolean b) {
		List<ShortcutAndWidgetContainer> containerList = mContent.getAllShortcutsAndWidgets();
		int size = containerList.size();
		for (int i = 0; i < size; i++) {
			containerList.get(i).setMotionEventSplittingEnabled(b);
		}
	}

    private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            return false;
        }

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        public void onDestroyActionMode(ActionMode mode) {
        }

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }
    };

    private boolean isAppAddView(Intent intent){
        return intent.getComponent() == null && TextUtils.isEmpty(intent.getAction());
    }

    public void onClick(View v) {
        //modify by lilu 屏蔽分享功能
        //begin add by linmaoqing 2014-5-14
//        if(MuchConfig.SUPPORT_MUCH_STYLE){
//            if(MuchAppShakeAndShareManager.getInstance().unStartApp()){
//                mLauncher.showShareDialog(v);
//                return;
//            }
//        }//end by linmaoqing
        //end by lilu

        Object tag = v.getTag();
        if(tag instanceof ShortcutInfo){
            Intent intent = ((ShortcutInfo)tag).getIntent();
            if(isAppAddView(intent)){
                List<ShortcutInfo> outAppList = LauncherAppState.getInstance().getModel().getOutAppList();
                showPop(outAppList);
                return;
            }
        }
        if (tag instanceof ShortcutInfo) {
            mLauncher.onClick(v);
        }
    }

    public boolean onLongClick(View v) {
        
        // Return if global dragging is not enabled
        if (!mLauncher.isDraggingEnabled()) return true;

        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }
            if(isAppAddView(item.getIntent())){
                return false;
            }

            mLauncher.dismissFolderCling(null);

            hideAddAppView();
            mLauncher.getWorkspace().onDragStartedWithItem(v);
            mLauncher.getWorkspace().beginDragShared(v, this);
            mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

            mCurrentDragInfo = item;
            mEmptyCell[0] = item.cellX;
            mEmptyCell[1] = item.cellY;
            mCurrentDragView = v;

            //add by linmaoqing 2014-4-5-14
            if(MuchConfig.SUPPORT_MUCH_STYLE){
//                MuchAppShakeAndShareManager.getInstance().handleClickToShake(true, false);
                
                int flocation[] = new int[2];
                v.getLocationOnScreen(flocation);
                CellLayout.LayoutParams lp = (com.android.launcher3.CellLayout.LayoutParams)v.getLayoutParams();
                mLauncher.getFloatMenuManager().setFolderPoint(flocation);
            }//end by linmaoqing

            //add by linmaoqing 2014-5-13
            if (MuchConfig.SUPPORT_MUCH_STYLE) {
                mContent.removeIconView(mCurrentDragView);
            } else {
                mContent.removeView(mCurrentDragView);
            }//end by linmaoqing
            mInfo.remove(mCurrentDragInfo);
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
        }
        return true;
    }

    public boolean isEditingName() {
        return mIsEditingName;
    }

    public void startEditingFolderName() {
        mFolderName.setHint("");
        mIsEditingName = true;
    }

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }

    public void doneEditingFolderName(boolean commit) {
        mFolderName.setHint(sHintText);
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String newTitle = mFolderName.getText().toString();
        mInfo.setTitle(newTitle);
        LauncherModel.updateItemInDatabase(mLauncher, mInfo);

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }
        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
        requestFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            dismissEditingName();
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }

    public Drawable getDragDrawable() {
        return mIconDrawable;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        //add by linmaoqing 2014-5-13
        if(MuchConfig.SUPPORT_MUCH_STYLE){
            float touchX = ev.getX();
            float touchY = ev.getY();
            if (!isPointInFolderFrame((int)touchX, (int)touchY)) {
                mLauncher.closeFolder();
            }
        } //end by linmaoqing
        return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    FolderInfo getInfo() {
        return mInfo;
    }

    private class GridComparator implements Comparator<ShortcutInfo> {
        int mNumCols;
        public GridComparator(int numCols) {
            mNumCols = numCols;
        }

        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            int lhIndex = lhs.cellY * mNumCols + lhs.cellX;
            int rhIndex = rhs.cellY * mNumCols + rhs.cellX;
            return (lhIndex - rhIndex);
        }
    }

    private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
        int maxX = 0;
        int count = items.size();
        for (int i = 0; i < count; i++) {
            ShortcutInfo item = items.get(i);
            if (item.cellX > maxX) {
                maxX = item.cellX;
            }
        }

        GridComparator gridComparator = new GridComparator(maxX + 1);
        Collections.sort(items, gridComparator);
        final int countX = mContent.getCountX();
        for (int i = 0; i < count; i++) {
            int x = i % countX;
            int y = i / countX;
            ShortcutInfo item = items.get(i);
            item.cellX = x;
            item.cellY = y;
        }
    }

    void bind(FolderInfo info) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;
        ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
        setupContentForNumItems(children.size());
        placeInReadingOrder(children);
        int count = 0;
        for (int i = 0; i < children.size(); i++) {
            ShortcutInfo child = (ShortcutInfo) children.get(i);
            if (!createAndAddShortcut(child)) {
                overflow.add(child);
            } else {
                count++;
            }
        }

        // We rearrange the items in case there are any empty gaps
        setupContentForNumItems(count);

        // If our folder has too many items we prune them from the list. This is an issue 
        // when upgrading from the old Folders implementation which could contain an unlimited
        // number of items.
        if(!MuchConfig.SUPPORT_MUCH_STYLE){  //add by linmaoqing 2014-5-13
            for (ShortcutInfo item: overflow) {
                mInfo.remove(item);
                LauncherModel.deleteItemFromDatabase(mLauncher, item);
            }
        }

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        if (!sDefaultFolderName.contentEquals(mInfo.title)) {
            mFolderName.setText(mInfo.title);
        } else {
            mFolderName.setText("");
        }
        updateItemLocationsInDatabase();
    }

    private View mAddAppView;
    private void setupAddView(final int lastCellX, final int lastCellY) {
        ShortcutInfo child = new ShortcutInfo();
        child.title = getResources().getString(R.string.add_app);
        child.id = -1;
        child.intent = new Intent();
        child.cellX = lastCellX == mContent.getCountX() - 1 ? 0 : lastCellX + 1;
        child.cellY = lastCellX == mContent.getCountX() - 1 ? lastCellY + 1 : lastCellY;
        createAndAddShortcut(child);

    }

    private void showAddAppView(){
        if (mAddAppView != null) {
            mAddAppView.setVisibility(View.VISIBLE);
        } else {
            mItemsInvalidated = true;
            ArrayList<View> list = getItemsInReadingOrderWithAbCoord();
            ShortcutInfo lastInfo = null;
            for (View view : list) {
                if (view != null && view.getTag() != null && view.getTag() instanceof ShortcutInfo) {
                    lastInfo = (ShortcutInfo) view.getTag();
                }
            }
            if (lastInfo != null) {
                setupAddView(lastInfo.cellX, lastInfo.cellY);
            }
        }
    }
    
    private void hideAddAppView(){
        int pageIndex = mContent.getCurrentItem();
        if(pageIndex == (mPageAdapter.getCount() - 1)){
        }
        if(mAddAppView != null){
            mContent.removeLastView(mAddAppView);
            mAddAppView = null;
            mContent.postInvalidate();
        }
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param context The application's context.
     *
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) { //add by linmaoqing 2014-5-12
        return (Folder) LayoutInflater.from(context).inflate(MuchConfig.SUPPORT_MUCH_STYLE ? R.layout.much_user_folder : R.layout.user_folder, null);
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        setScaleX(0.8f);
        setScaleY(0.8f);
        setAlpha(0f);
        mState = STATE_SMALL;
    }

    public void animateOpen() {
        positionAndSizeAsIcon();

        if (!(getParent() instanceof DragLayer)) return;
        centerAboutIcon();
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
        final ObjectAnimator oa =
            LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);

        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        String.format(getContext().getString(R.string.folder_opened),
                        mContent.getCountX(), mContent.getCountY()));
                mState = STATE_ANIMATING;
                if(MuchConfig.SUPPORT_MUCH_STYLE){
                    showAddAppView();
                }
            }
            @Override
            public void onAnimationEnd(Animator animation) {
                mState = STATE_OPEN;
                setLayerType(LAYER_TYPE_NONE, null);
                //edit begin by lilu 20140519
                if (!MuchConfig.SUPPORT_MUCH_STYLE) {
                	Cling cling = mLauncher.showFirstRunFoldersCling();
                	if (cling != null) {
                		cling.bringScrimToFront();
                		bringToFront();
                		cling.bringToFront();
                	}
                }
                //edit end by lilu 20140519
                setFocusOnFirstChild();
            }
        });
        oa.setDuration(mExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        oa.start();
    }

    private void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    private void setFocusOnFirstChild() {
        View firstChild = mContent.getChildAt(0, 0);
        if (firstChild != null) {
            firstChild.requestFocus();
        }
    }

    public void animateClosed() {
        if (!(getParent() instanceof DragLayer)) return;
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0.9f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0.9f);
        final ObjectAnimator oa =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);

        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                onCloseComplete();
                setLayerType(LAYER_TYPE_NONE, null);
                mState = STATE_SMALL;
            }
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        getContext().getString(R.string.folder_closed));
                mState = STATE_ANIMATING;
            }
        });
        oa.setDuration(mExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        oa.start();
    }

    public boolean acceptDrop(DragObject d) {
        final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                    itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
                    !isFull());
    }

    protected boolean findAndSetEmptyCells(ShortcutInfo item) {
        int[] emptyCell = new int[2];
        if (mContent.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
            item.cellX = emptyCell[0];
            item.cellY = emptyCell[1];
            return true;
        } else {
            return false;
        }
    }

    protected boolean createAndAddShortcut(ShortcutInfo item) {
        final BubbleTextView textView =
            (BubbleTextView) mInflater.inflate(R.layout.application, this, false);
        if(MuchConfig.SUPPORT_MUCH_STYLE) {
            if(!isAppAddView(item.getIntent())){//有可能为快捷方式
                LauncherAppState.getInstance().getIconDecorater().observeIconNeedUpdated(textView, item.getIcon(mIconCache), item.intent.getComponent());
            }else{
                Bitmap bmp = BitmapFactory.decodeResource(
                        getResources(), R.drawable.snail_folder_add_app);
                textView.setCompoundDrawables(null, Utilities.createIconDrawable(bmp), null, null);
                mAddAppView = textView;
            }
        }else{
            textView.setCompoundDrawables(null,
                    Utilities.createIconDrawable(item.getIcon(mIconCache)), null, null);
        }
        textView.setText(item.title);
        textView.setTag(item);
        textView.setTextColor(getResources().getColor(R.color.folder_items_text_color));
        textView.setShadowsEnabled(false);

        textView.setOnClickListener(this);
        textView.setOnLongClickListener(this);

        // We need to check here to verify that the given item's location isn't already occupied
        // by another item.
        if (mContent.getChildAt(item.cellX, item.cellY) != null || item.cellX < 0 || item.cellY < 0
                || item.cellX >= mContent.getCountX() || item.cellY >= mContent.getCountY()) {
            // This shouldn't happen, log it. 
            Log.e(TAG, "Folder order not properly persisted during bind");
            if (!findAndSetEmptyCells(item)) {
                return false;
            }
        }

        CellLayout.LayoutParams lp =
            new CellLayout.LayoutParams(item.cellX, item.cellY, item.spanX, item.spanY);
        boolean insert = false;
        textView.setOnKeyListener(new FolderKeyEventListener());
        mContent.addViewToCellLayout(textView, insert ? 0 : -1, (int)item.id, lp, true);
        return true;
    }

    public void onDragEnter(DragObject d) {
        mPreviousTargetCell[0] = -1;
        mPreviousTargetCell[1] = -1;
        mOnExitAlarm.cancelAlarm();
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            realTimeReorder(mEmptyCell, mTargetCell);
        }
    };

    boolean readingOrderGreaterThan(int[] v1, int[] v2) {
        if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
            return true;
        } else {
            return false;
        }
    }

    private void realTimeReorder(int[] empty, int[] target) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int delay = 0;
        float delayAmount = 30;
        if (readingOrderGreaterThan(target, empty)) {
            wrap = empty[0] >= mContent.getCountX() - 1;
            startY = wrap ? empty[1] + 1 : empty[1];
            for (int y = startY; y <= target[1]; y++) {
                startX = y == empty[1] ? empty[0] + 1 : 0;
                endX = y < target[1] ? mContent.getCountX() - 1 : target[0];
                for (int x = startX; x <= endX; x++) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        } else {
            wrap = empty[0] == 0;
            startY = wrap ? empty[1] - 1 : empty[1];
            for (int y = startY; y >= target[1]; y--) {
                startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX() - 1;
                endX = y > target[1] ? 0 : target[0];
                for (int x = startX; x >= endX; x--) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        }
    }

    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }

    public void onDragOver(DragObject d) {
        final DragView dragView = d.dragView;
        int scrollOffset = 0;	//delete final by linmaoqing 2014-5-13
        if (!MuchConfig.SUPPORT_MUCH_STYLE) { //add by linmaoqing 2014-5-14
            scrollOffset = mScrollView.getScrollY();
		}//end by linmaoqing
        final float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, dragView, null);
        int centerCoordinateOffset[] = new int[2];
        if(MuchConfig.SUPPORT_MUCH_STYLE){
            if(LauncherAppState.isScreenLandscape(mLauncher)){
                centerCoordinateOffset[0] =  getResources().getDimensionPixelOffset(R.dimen.landscape_folder_item_drag_x_coordinate_offset);
                centerCoordinateOffset[1] = getResources().getDimensionPixelOffset(R.dimen.landscape_folder_item_drag_x_coordinate_offset);
            } else {
                centerCoordinateOffset[0] = getResources().getDimensionPixelOffset(R.dimen.portait_folder_item_drag_x_coordinate_offset);
                centerCoordinateOffset[1] = getResources().getDimensionPixelOffset(R.dimen.portait_folder_item_drag_y_coordinate_offset);
            }
        }
        r[0] -= getPaddingLeft();
        r[1] -= getPaddingTop();
        //add by linmaoqing 2014-5-13
        if (MuchConfig.SUPPORT_MUCH_STYLE) {
            if (!isPointInFolderFrame((int)r[0], (int)r[1])) {
                mLauncher.closeFolder();
                return;
            }
        }//end by linmaoqing
        final long downTime = SystemClock.uptimeMillis();
        final MotionEvent translatedEv = MotionEvent.obtain(
                downTime, downTime, MotionEvent.ACTION_MOVE, d.x, d.y, 0);
        //modify by linmaoqing 2014-5-13
        if(!MuchConfig.SUPPORT_MUCH_STYLE){
            if (!mAutoScrollHelper.isEnabled()) {
                mAutoScrollHelper.setEnabled(true);
            }
        }//end by linmaoqing
        boolean handled = false;
        //add by linmaoqing 2014-5-13
        if(!MuchConfig.SUPPORT_MUCH_STYLE){
            handled = mAutoScrollHelper.onTouch(this, translatedEv); //delete final by linmaoqing 2014-5-13
        } // end by linmaoqing
        translatedEv.recycle();
        if (handled) {
            mReorderAlarm.cancelAlarm();
        } else {
            mTargetCell = mContent.findNearestArea(
                    (int) r[0]-centerCoordinateOffset[0], (int) r[1] + scrollOffset-centerCoordinateOffset[1], 1, 1, mTargetCell);
            if (isLayoutRtl()) {
                mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
            }
            
            if (mTargetCell[0] != mPreviousTargetCell[0]
                    || mTargetCell[1] != mPreviousTargetCell[1]) {
                mReorderAlarm.cancelAlarm();
                mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                mReorderAlarm.setAlarm(REORDER_DELAY);
                mPreviousTargetCell[0] = mTargetCell[0];
                mPreviousTargetCell[1] = mTargetCell[1];
                mDragMode = DRAG_MODE_REORDER;
            } else {
                mDragMode = DRAG_MODE_NONE;
            }
        }
    }

    // This is used to compute the visual center of the dragView. The idea is that
    // the visual center represents the user's interpretation of where the item is, and hence
    // is the appropriate point to use when determining drop location.
    private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
            DragView dragView, float[] recycle) {
        float res[];
        if (recycle == null) {
            res = new float[2];
        } else {
            res = recycle;
        }

        // These represent the visual top and left of drag view if a dragRect was provided.
        // If a dragRect was not provided, then they correspond to the actual view left and
        // top, as the dragRect is in that case taken to be the entire dragView.
        // R.dimen.dragViewOffsetY.
        int left = x - xOffset;
        int top = y - yOffset;

        // In order to find the visual center, we shift by half the dragRect
        res[0] = left + dragView.getDragRegion().width() / 2;
        res[1] = top + dragView.getDragRegion().height() / 2;

        return res;
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

    public void completeDragExit() {
        mLauncher.closeFolder();
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mRearrangeOnClose = true;
    }

    public void onDragExit(DragObject d) {
        // Exiting folder; stop the auto scroller.
        if(!MuchConfig.SUPPORT_MUCH_STYLE){
            mAutoScrollHelper.setEnabled(false); //  add by linmaoqing 2014-5-13
        }
        // We only close the folder if this is a true drag exit, ie. not because
        // a drop has occurred above the folder.
        if (!d.dragComplete) {
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
        }
        mReorderAlarm.cancelAlarm();
        mDragMode = DRAG_MODE_NONE;
    }

    public void onDropCompleted(final View target, final DragObject d,
            final boolean isFlingToDelete, final boolean success) {
        if (mDeferDropAfterUninstall) {
            Log.d(TAG, "Deferred handling drop because waiting for uninstall.");
            mDeferredAction = new Runnable() {
                    public void run() {
                        onDropCompleted(target, d, isFlingToDelete, success);
                        mDeferredAction = null;
                    }
                };
            return;
        }

        //add by linmaoqing 2015-11-16
        createFloatMenu();
        boolean beingCalledAfterUninstall = mDeferredAction != null;
        boolean successfulDrop =
                success && (!beingCalledAfterUninstall || mUninstallSuccessful);
        if (successfulDrop) {
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon) {
                replaceFolderWithFinalItem();
            }
        } else {
            setupContentForNumItems(getItemCount());
            // The drag failed, we need to return the item to the folder
            mFolderIcon.onDrop(d);
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                if(MuchConfig.SUPPORT_MUCH_STYLE) {
                    mCurrentDragInfo = null;
                }
                if (!successfulDrop) {
                    mSuppressFolderDeletion = true;
                }
                completeDragExit();
            }
        }

        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;

        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabaseBatch();
        
        if(MuchConfig.SUPPORT_MUCH_STYLE){
            showAddAppView();
        }
    }

    private void createFloatMenu() {
        if(mCurrentDragInfo != null && mCurrentDragView !=null && mDragController.isMotionValid()){
            boolean isOnlyDelete = false;
            if (mCurrentDragInfo.itemType == Favorites.ITEM_TYPE_APPWIDGET || mCurrentDragInfo.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
                isOnlyDelete = true;
            }
            mLauncher.getFloatMenuManager().createFloatMenu(mCurrentDragView,mCurrentDragInfo.cellX,mCurrentDragInfo.cellY,isOnlyDelete);
        }
    }

    public void deferCompleteDropAfterUninstallActivity() {
        mDeferDropAfterUninstall = true;
    }

    public void onUninstallActivityReturned(boolean success) {
        mDeferDropAfterUninstall = false;
        mUninstallSuccessful = success;
        if (mDeferredAction != null) {
            mDeferredAction.run();
        }
    }

    @Override
    public boolean supportsFlingToDelete() {
        return true;
    }

    public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
        // Do nothing
    }

    @Override
    public void onFlingToDeleteCompleted() {
        // Do nothing
    }

    private void updateItemLocationsInDatabase() {
        //modify by lilu 修复第二页图标不显示的问题
//        ArrayList<View> list = getItemsInReadingOrder();
        ArrayList<View> list = getItemsInReadingOrderWithAbCoord();
        //end by lilu
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
        }
    }

    private void updateItemLocationsInDatabaseBatch() {
        //modify by lilu 修复第二页图标不显示的问题
//      ArrayList<View> list = getItemsInReadingOrder();
      ArrayList<View> list = getItemsInReadingOrderWithAbCoord();
      //end by lilu
        ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            if(MuchConfig.SUPPORT_MUCH_STYLE && info.getIntent().getComponent() != null){
                items.add(info);
            }
        }

        LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
    }

    public void addItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY, false);
        }
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return true;
    }

    private void setupContentDimensions(int count) {
        ArrayList<View> list = getItemsInReadingOrder();

        int countX = mContent.getCountX();
        int countY = mContent.getCountY();
        boolean done = false;

        while (!done) {
            int oldCountX = countX;
            int oldCountY = countY;
            if (countX * countY < count) {
                // Current grid is too small, expand it
                if ((countX <= countY || countY == mMaxCountY) && countX < mMaxCountX) {
                    countX++;
                } else if (countY < mMaxCountY) {
                    countY++;
                }
                if (countY == 0) countY++;
            } else if ((countY - 1) * countX >= count && countY >= countX) {
                countY = Math.max(0, countY - 1);
            } else if ((countX - 1) * countY >= count) {
                countX = Math.max(0, countX - 1);
            }
            done = countX == oldCountX && countY == oldCountY;
        }
        if(!MuchConfig.SUPPORT_MUCH_STYLE) {
            mContent.setGridSize(countX, countY);
        }
        arrangeChildren(list);
    }

    public boolean isFull() {
        if(MuchConfig.SUPPORT_MUCH_STYLE){ //add by linmaoqing 2014-5-13
            return false;
        }//end by linmaoqing
        return getItemCount() >= mMaxNumItems;
    }
    //add by linmaoqing 2014-5-13
    public int getFolderFrameWidth() {
        return mFolderFrame.getWidth();
    }

    public int getFolderFrameHeigth() {
        return mFolderFrame.getHeight();
    }

    public LinearLayout getFolderFrameLayout() {
        return mFolderFrame;
    }

    public void setFolderFrameBg(Drawable bg) {
        mFolderFrame.setBackground(bg);
    }
    //end by linmaoqing
    private void centerAboutIcon() {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        LayoutParams linearLp = (LayoutParams)mFolderFrame.getLayoutParams();//add by linmaoqing 2014-5-13
        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        int width,height;
        if(MuchConfig.SUPPORT_MUCH_STYLE){  //add by linmaoqing 2014-5-13
            width = mLauncher.getWindow().getDecorView().getWidth();
            height = mLauncher.getWindow().getDecorView().getHeight();
        }else{
            width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
            height = getFolderHeight();
        }//end by linmaoqing 2014-5-13
        float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);

        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();

        int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
        int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
        int centeredLeft = centerX - width / 2;
        int centeredTop = centerY - height / 2;
        if(MuchConfig.SUPPORT_MUCH_STYLE){//add by linmaoqing 2014-5-27
            if(mLauncher.getWorkspace() == null){
                return;
            }
        }
        int currentPage = mLauncher.getWorkspace().getNextPage();
        // In case the workspace is scrolling, we need to use the final scroll to compute
        // the folders bounds.
        mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
        // We first fetch the currently visible CellLayoutChildren
        CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace().getChildAt(currentPage);
        Rect bounds = new Rect();
        if (currentLayout != null) {
            ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
            parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
        }
        // We reset the workspaces scroll
        mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);

        // We need to bound the folder to the currently visible CellLayoutChildren
        int left = Math.min(Math.max(bounds.left, centeredLeft),
                bounds.left + bounds.width() - width);
        int top = Math.min(Math.max(bounds.top, centeredTop),
                bounds.top + bounds.height() - height);
        if (grid.isPhone() && (grid.availableWidthPx - width) < grid.iconSizePx) {
            // Center the folder if it is full (on phones only)
            left = (grid.availableWidthPx - width) / 2;
        } else if (width >= bounds.width()) {
            // If the folder doesn't fit within the bounds, center it about the desired bounds
            left = bounds.left + (bounds.width() - width) / 2;
        }
        if (height >= bounds.height()) {
            top = bounds.top + (bounds.height() - height) / 2;
        }

        int folderPivotX = width / 2 + (centeredLeft - left);
        int folderPivotY = height / 2 + (centeredTop - top);
        setPivotX(folderPivotX);
        setPivotY(folderPivotY);
        mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() *
                (1.0f * folderPivotX / width));
        mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() *
                (1.0f * folderPivotY / height));

        lp.width = width;
        lp.height = height;
        //add by linmaoqing 2014-5-13
        if (MuchConfig.SUPPORT_MUCH_STYLE) {
            int frameWidth = mFolderFrame.getPaddingLeft() + mFolderFrame.getPaddingRight()
                    + mContent.getDesiredWidth();
            int frameHeigth = mFolderFrame.getPaddingTop() + mFolderFrame.getPaddingBottom()
                    + mContent.getDesiredHeight() + mFolderNameHeight + mIndicatorHeight;
            Rect frame = new Rect();
            mLauncher.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);
            mStatusBarHeigth = frame.top;
            Display display = mLauncher.getWindowManager().getDefaultDisplay();
            linearLp.leftMargin = (display.getWidth() - frameWidth) / 2;
            linearLp.topMargin = (display.getHeight() - frameHeigth + mStatusBarHeigth) / 2;
            lp.x = 0;
            lp.y = 0;
        } else {
          lp.x = left;
          lp.y = top;
        }// end by linmaoqing 2014-5-13
    }

    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    private void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        centerAboutIcon();
    }

    private int getContentAreaHeight() {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        Rect workspacePadding = grid.getWorkspacePadding(grid.isLandscape ?
                CellLayout.LANDSCAPE : CellLayout.PORTRAIT);
        int maxContentAreaHeight = grid.availableHeightPx -
                4 * grid.edgeMarginPx -
                workspacePadding.top - workspacePadding.bottom -
                getPaddingTop() - getPaddingBottom() -
                mFolderNameHeight;
        return Math.min(maxContentAreaHeight,
                mContent.getDesiredHeight());
    }

    private int getFolderHeight() {
        int height = getPaddingTop() + getPaddingBottom()
                + getContentAreaHeight() + mFolderNameHeight;
        return height;
    }

    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //add by linmaoqing 2014-5-13
        int width,height;
        if(MuchConfig.SUPPORT_MUCH_STYLE){  //add by linmaoqing 2014-5-13
            width = mLauncher.getWindow().getDecorView().getWidth();
            height = mLauncher.getWindow().getDecorView().getHeight();
        }else{//end by linmaoqing 2014-5-13
            width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
            height = getFolderHeight();
        }
        if(MuchConfig.SUPPORT_MUCH_STYLE){ //add by linmaoqing 2014-5-13
            int frameWidth = mFolderFrame.getPaddingLeft() + mFolderFrame.getPaddingRight()
                    + mContent.getDesiredWidth();
            int frameHeigth = mFolderFrame.getPaddingTop() + mFolderFrame.getPaddingBottom() + mContent.getDesiredHeight()
                    + mFolderNameHeight + mIndicatorHeight;
            mFolderFrame.measure(MeasureSpec.makeMeasureSpec(frameWidth,
                    MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(frameHeigth,
                            MeasureSpec.EXACTLY));
            int contentWidthSpec = MeasureSpec.makeMeasureSpec(mContent.getDesiredWidth(),
                    MeasureSpec.EXACTLY);
            int contentHeightSpec = MeasureSpec.makeMeasureSpec(mContent.getDesiredHeight(),
                    MeasureSpec.EXACTLY);
            mContent.measure(contentWidthSpec, contentHeightSpec);
            mFolderName.measure(contentWidthSpec,
                    MeasureSpec.makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
            mViewPageIndicator.measure(contentWidthSpec, 
                    MeasureSpec.makeMeasureSpec(mIndicatorHeight, MeasureSpec.EXACTLY));
        }else{ //end by linmaoqing
            int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(mContent.getDesiredWidth(),
                    MeasureSpec.EXACTLY);
            int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(getContentAreaHeight(),
                    MeasureSpec.EXACTLY);
            mContent.setFixedSize(mContent.getDesiredWidth(), mContent.getDesiredHeight());
            mScrollView.measure(contentAreaWidthSpec, contentAreaHeightSpec);  //modify by linmaoqing 2014-5-13
            mFolderName.measure(contentAreaWidthSpec,
                    MeasureSpec.makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
        }
        setMeasuredDimension(width, height);
    }

    private void arrangeChildren(ArrayList<View> list) {
        
        int[] vacant = new int[2];
        if (MuchConfig.SUPPORT_MUCH_STYLE) { // add by linmaoqing 2014-5-13
            list = getItemsInReadingOrderWithAbCoord();
        } else { //end by linmaoqing
	        if (null == list) {
	            list = getItemsInReadingOrder();
	        }
        }
        mContent.removeAllViews();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            //modify by lilu 修复第二页图标不显示的问题
//            mContent.getVacantCell(vacant, 1, 1);
            mContent.getVacantCellAbCoord(vacant, 1, 1);
            //end by lilu
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
            lp.cellX = vacant[0];
            lp.cellY = vacant[1];
            ItemInfo info = (ItemInfo) v.getTag();
            if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
                info.cellX = vacant[0];
                info.cellY = vacant[1];
                if(info.getIntent().getComponent() != null){ //防止+号排序时插入数据库
                    LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, 0,
                            info.cellX, info.cellY);
                }
            }
            boolean insert = false;
            mContent.addViewToCellLayout(v, insert ? 0 : -1, (int)info.id, lp, true);
        }
        mItemsInvalidated = true;
    }
    // add by linmaoqing 2014-5-13
    public ArrayList<View> getItemsInReadingOrderWithAbCoord() {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            for (int j = 0; j < mContent.getCountY(); j++) {
                for (int i = 0; i < mContent.getCountX(); i++) {
                    View v = mContent.getChildAtByAbsoluteCoord(i, j);
                    if (v != null) {
                        mItemsInReadingOrder.add(v);
                    }
                }
            }
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    } // end by linmaoqing

    public int getItemCount() {
        if(MuchConfig.SUPPORT_MUCH_STYLE){ //add by linmaoqing 2014-5-13
            return mContent.getAllShortcutContainerChildCount();
        } //end by linmaoqing
        return mContent.getShortcutsAndWidgets().getChildCount();
    }

    public View getItemAt(int index) {
        return mContent.getShortcutsAndWidgets().getChildAt(index);
    }

    private void onCloseComplete() {
        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
        }
        mDragController.removeDropTarget((DropTarget) this);
        clearFocus();
        mFolderIcon.requestFocus();

//        if (mRearrangeOnClose) { //modify by linmaoqing 2015-10-30 解决app拖出文件夹后空格问题
            setupContentForNumItems(getItemCount());
            mRearrangeOnClose = false;
//        }
        if (mInfo.contents.size() <= 1) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
      //关闭文件夹前检查空页并删除  add by linmaoqing 2014-5-13
        if (MuchConfig.SUPPORT_MUCH_STYLE) {
            mContent.checkAndRemoveEmptyPage();
            mContent.setCurrentItem(0);
        }//end by linmaoqing
        mSuppressFolderDeletion = false;
        
        if(MuchConfig.SUPPORT_MUCH_STYLE){
            hideAddAppView();
            if(mPopWind != null){
                mPopWind.dismiss();
            }
        }
    }

    private void replaceFolderWithFinalItem() {
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screenId);
               View child = null;
                // Move the item from the folder to the workspace, in the position of the folder
                if (mInfo.contents.size() == 1) {
                    ShortcutInfo finalItem = mInfo.contents.get(0);
                    
                    child = mLauncher.createShortcut(R.layout.application, cellLayout,
                            finalItem);
                    LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                            mInfo.screenId, mInfo.cellX, mInfo.cellY);
                    mInfo.contents.clear();//清除文件夹最后一个item
                }
                if (mInfo.contents.size() <= 1) {//modify by linmaoqing 2015-10-30
                    // Remove the folder
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    if (cellLayout != null) {
                        cellLayout.removeView(mFolderIcon);
                    }
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                    if(MuchConfig.SUPPORT_MUCH_STYLE) {//add by linmaoqing 2014-5-13
                        mContent.removeAllViews();
                    }//end by linmaoqing
                }
                // We add the child after removing the folder to prevent both from existing at
                // the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()
                // to ensure that hotseat items are placed correctly.
                if (child != null) {
                    if(mLauncher.getWorkspace() != null){
                        mLauncher.getWorkspace().addInScreenFromBind(child, mInfo.container, mInfo.screenId,
                                mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
                    }
                }
            }
        };
        View finalChild = getFirstChild();//modify by linmaoqing2015-12-11 修复移除文件夹中应用后形成空文件夹问题
        if (finalChild != null) {
            mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
        }else{
            onCompleteRunnable.run();
        }
        mDestroyed = true;
    }
    
    /**
     * add by linmaoqing 2015-12-11
     * @return
     */
    public View getFirstChild(){
        return mContent.getChildAtByAbsoluteCoord(0, 0);
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    private void updateTextViewFocus() {
        View lastChild = getItemAt(getItemCount() - 1);
        getItemAt(getItemCount() - 1);
        if (lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
        }
    }

    public void onDrop(DragObject d) {
        ShortcutInfo item;
        if (d.dragInfo instanceof AppInfo) {
            // Came from all apps -- make a copy
            item = ((AppInfo) d.dragInfo).makeShortcut();
            item.spanX = 1;
            item.spanY = 1;
        } else {
            item = (ShortcutInfo) d.dragInfo;
        }
        // Dragged from self onto self, currently this is the only path possible, however
        // we keep this as a distinct code path.
        if (item == mCurrentDragInfo) {
            ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView.getLayoutParams();
            if (MuchConfig.SUPPORT_MUCH_STYLE) {
                lp.cellX = mEmptyCell[0];
                lp.cellY = mEmptyCell[1];
                si.cellX = mEmptyCell[0];
                si.cellY = mContent.getYIndexInAllPage(mEmptyCell[1]);
            } else {
                si.cellX = lp.cellX = mEmptyCell[0];
                si.cellX = lp.cellY = mEmptyCell[1];
            }
            if (MuchConfig.SUPPORT_MUCH_STYLE) {
                mContent.addViewToCurrentCellLayout(mCurrentDragView, -1, (int)item.id, lp, true);
            } else {
                mContent.addViewToCellLayout(mCurrentDragView, -1, (int)item.id, lp, true);
			}
            if (d.dragView.hasDrawn()) {
                mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, mCurrentDragView);
            } else {
                d.deferDragViewCleanupPostAnimation = false;
                mCurrentDragView.setVisibility(VISIBLE);
            }
            mItemsInvalidated = true;
            setupContentDimensions(getItemCount());
            mSuppressOnAdd = true;
        }
        mInfo.add(item);
    }

    // This is used so the item doesn't immediately appear in the folder when added. In one case
    // we need to create the illusion that the item isn't added back to the folder yet, to
    // to correspond to the animation of the icon back into the folder. This is
    public void hideItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        if (v != null) {
            v.setVisibility(INVISIBLE);
        }
    }
    public void showItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        if (v != null) {
            v.setVisibility(VISIBLE);
        }
    }

    public void onAdd(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        if (mSuppressOnAdd) return;
        if (!findAndSetEmptyCells(item)) {
            // The current layout is full, can we expand it?
            setupContentForNumItems(getItemCount() + 1);
            findAndSetEmptyCells(item);
        }
        createAndAddShortcut(item);
        LauncherModel.addOrMoveItemInDatabase(
                mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
    }

    public void onRemove(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        
        View v = getViewForInfo(item);
        if (MuchConfig.SUPPORT_MUCH_STYLE) {
            mContent.removeIconView(v);
        } else {
            mContent.removeView(v);
        }
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            setupContentForNumItems(getItemCount());
        }
        if (mInfo.contents.size() <= 1) {//modify by linmaoqing 
            replaceFolderWithFinalItem();
        }
    }

    private View getViewForInfo(ShortcutInfo item) {
        for (int j = 0; j < mContent.getCountY(); j++) {
            for (int i = 0; i < mContent.getCountX(); i++) {
                View v = null;
                if(MuchConfig.SUPPORT_MUCH_STYLE){
                    v = mContent.getChildAtByAbsoluteCoord(i, j);
                }else{
                    v = mContent.getChildAt(i, j);
                }
                if (v!=null && v.getTag() == item) {// modify by linmaoqing 2014-5-13
                    return v;
                }
            }
        }
        return null;
    }

    public void onItemsChanged() {
        updateTextViewFocus();
    }

    public void onTitleChanged(CharSequence title) {
    }

    public ArrayList<View> getItemsInReadingOrder() {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            for (int j = 0; j < mContent.getCountY(); j++) {
                for (int i = 0; i < mContent.getCountX(); i++) {
                    View v = null;
                    if(MuchConfig.SUPPORT_MUCH_STYLE){
                        v = mContent.getChildAtByAbsoluteCoord(i,j);// add by linmaoqing 2014-5-13
                    }else{
                        v = mContent.getChildAt(i, j);
                    }
                    if (v != null) {
                        mItemsInReadingOrder.add(v);
                    }
                }
            }
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public void getLocationInDragLayer(int[] loc) {
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName && hasFocus) {
            startEditingFolderName();
        }
    }

    @Override
    public void getHitRectRelativeToDragLayer(Rect outRect) {
        getHitRect(outRect);
    }
    //add by linmaoqing 2014-5-13
    private boolean isPointInFolderFrame(int x,int y) {
        if (x < mFolderFrame.getLeft()
                || x > mFolderFrame.getLeft() + mFolderFrame.getWidth()
                || y < mFolderFrame.getTop()
                || y > mFolderFrame.getTop() + mFolderFrame.getHeight()) {
            return false;
        }
        return true;
    }//end by linmaoqing
    
    private PopupWindow mPopWind;
    private MuchDraggableGridViewPager mMuchGridPager;
    private TextView mSelectCount;
    private TextView mConfirm,mCancel;
    public AddAllData mAllData = new  AddAllData();
    static class AddAllData{
        public ArrayList<ItemInfo> all = new ArrayList<ItemInfo>();
        public ArrayList<ItemInfo> selectList = new ArrayList<ItemInfo>();
        public ArrayList<ItemInfo> addList = new ArrayList<ItemInfo>();
        public ArrayList<ItemInfo> removeList = new ArrayList<ItemInfo>();
        
        public void clearAllData(){
            all.clear();
            selectList.clear();
            addList.clear();
            removeList.clear();
        }
    }
    
    public void clearAllData(){
        mAllData.clearAllData();
    }
    public void showPop(List<ShortcutInfo> outAppList){
        View layout;
        clearAllData();
        hideAddAppView();
        if (mPopWind == null) { 
            mAllData.selectList.addAll(mInfo.contents);
            layout = LayoutInflater.from(mLauncher).inflate(R.layout.much_draggable_grid_view_pager, null);  
            mMuchGridPager = (MuchDraggableGridViewPager) layout.findViewById(R.id.draggable_grid_view_pager);
            mSelectCount = (TextView)layout.findViewById(R.id.title);
            mSelectCount.setText(String.format(getResources().getString(R.string.add_app_count), mAllData.selectList.size()));
            mConfirm = (TextView)layout.findViewById(R.id.confirm);
            mCancel = (TextView)layout.findViewById(R.id.cancel);
            mConfirm.setOnClickListener(new ConfirmOnClickListener());
            mCancel.setOnClickListener(new ConfirmOnClickListener());
            
            mAllData.all.addAll(0,mAllData.selectList);
            mAllData.all.addAll(outAppList);
            MyAdapter mAdapter = new MyAdapter(mLauncher, mAllData.all);
            mMuchGridPager.setAdapter(mAdapter);
            mMuchGridPager.setOnPageChangeListener(new OnPageChangeListener() {
                
                @Override
                public void onPageSelected(int position) {
                    // TODO Auto-generated method stub
                    
                }
                
                @Override
                public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
                    // TODO Auto-generated method stub
                    
                }
                
                @Override
                public void onPageScrollStateChanged(int state) {
                    // TODO Auto-generated method stub
                    
                }
            });
            mMuchGridPager.setOnItemClickListener(new OnItemClickListener() {
                @Override
                public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                    ViewHolder holder = (ViewHolder) view.getTag();
                    holder.isSelected = !holder.isSelected;
                    if (holder.isSelected) {
                        holder.selectedView.setVisibility(View.VISIBLE);
                        mAllData.selectList.add(holder.item);
                        if (!mAllData.addList.contains(holder.item)) {
                            mAllData.addList.add(holder.item);// 如果文件夹没有，添加到新增列表
                        }
                    } else {
                        holder.selectedView.setVisibility(View.INVISIBLE);
                        mAllData.selectList.remove(holder.item);
                        if (!mAllData.removeList.contains(holder.item) ) {
                            mAllData.removeList.add(holder.item);// 如果文件夹已有，添加到移除列表
                        }
                    }
                    mSelectCount.setText(String.format(getResources().getString(R.string.add_app_count),
                            mAllData.selectList.size()));
                }
            });
            int width = getResources().getDimensionPixelOffset(R.dimen.much_folder_add_app_pop_window_width);
            int height = getResources().getDimensionPixelOffset(R.dimen.much_folder_add_app_pop_window_height);
            mPopWind = new PopupWindow(layout,width,height);  
        }  
        mPopWind.setFocusable(true);  
        mPopWind.setOutsideTouchable(true);  
        // 这个是为了点击“返回Back”也能使其消失，并且并不会影响你的背景  
        mPopWind.setBackgroundDrawable(new BitmapDrawable());  
  
        mPopWind.showAtLocation(mLauncher.getDragLayer(), Gravity.CENTER, 0, 0);
        mPopWind.setOnDismissListener(new OnDismissListener() {
            
            @Override
            public void onDismiss() {
                showAddAppView();
                mMuchGridPager.removeAllViewsInLayout();
                mPopWind = null;
            }
        });
    }
    
    /**
     * 更新文件夹items
     */
    protected void updateFolderItemsBatch() {
        //删除既添加又删除的数据
        checkData();
        
        //添加文件夹中选中的应用图标,先移除，后添加，避免桌面位置占用问题
        addSelectedItemsToFolder();
        
        //移除文件夹未选中的应用图标
        removeUnSelectedItemsFromFolder();
        
    }

    private void checkData() {
        HashSet<ItemInfo> infoSet = new HashSet<ItemInfo>();
        if (!mAllData.addList.isEmpty() && !mAllData.removeList.isEmpty()) {
            for (ItemInfo info : mAllData.addList) {
                if (mAllData.removeList.contains(info)) {
                    infoSet.add(info);
                }
            }
            for (ItemInfo sameInfo : infoSet) {
                mAllData.addList.remove(sameInfo);
                mAllData.removeList.remove(sameInfo);
            }
        }
    }

    private void removeUnSelectedItemsFromFolder() {
        //未选中的显示在桌面
        if(!mAllData.removeList.isEmpty()){
            for(ItemInfo info : mAllData.removeList){
                if(info instanceof ShortcutInfo){
                    ShortcutInfo sInfo = (ShortcutInfo)info;
                    onRemoveBatch(sInfo);
                }
            }

            arrangeAfterRemoveBatch();
            
            LauncherAppState appState = LauncherAppState.getInstance();
            WeakReference<Callbacks> callbacks = appState.getModel().getCallbacks();
            // Ensure that we add all the workspace applications to the db
            Callbacks cb = callbacks != null ? callbacks.get() : null;
            
            final ArrayList<ItemInfo> addedInfos = new ArrayList<ItemInfo>(mAllData.removeList);
            appState.getModel().folderAppsToUnBind(appState.getContext(), addedInfos, cb, new ArrayList<AppInfo>());
        }
    }

    public void onRemoveBatch(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        mInfo.contents.remove(item);
        View v = getViewForInfo(item);
        if (MuchConfig.SUPPORT_MUCH_STYLE) {
            mContent.removeIconView(v);
        } else {
            mContent.removeView(v);
        }
        if (mInfo.contents.size() <= 1) {
            onCloseComplete();
        }
    }
    
    private void arrangeAfterRemoveBatch(){
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            if (mInfo.contents.size() >= FOLDER_MIN_APP) {// 当文件夹>=2个应用时，对文件夹进行排序
                setupContentForNumItems(getItemCount());
            }
        }
    }

    private void removeView(ItemInfo item) {
        CellLayout celllayout = mLauncher.getCellLayout(item.container, item.screenId);
        if(celllayout != null){
            View v = celllayout.getChildAt(item.cellX, item.cellY);
            if(v != null){
                celllayout.removeView(v);
            }
        }
    }

    //modified by lilu 20160217
    private void addSelectedItemsToFolder() {
        for(ItemInfo info : mAllData.addList){
            if(info instanceof ShortcutInfo && !mInfo.contents.contains(info)){
                //remove the icon view from workspace,but not modify the database
                removeView(info);
            }
        }
        //选中的显示在文件夹
        for(ItemInfo info : mAllData.addList){
            if(info instanceof ShortcutInfo && !mInfo.contents.contains(info)){
                ShortcutInfo sInfo = (ShortcutInfo)info;
                //just change the modify record ,not added
                onAdd(sInfo);
                mInfo.contents.add(sInfo);
            }
        }
    }
    //modified end by lilu 20160217

    class ConfirmOnClickListener implements OnClickListener {

        @Override
        public void onClick(View v) {
            if(v.getId() == R.id.confirm){
                updateFolderItemsBatch();
            }
            if (mPopWind != null) {
                mPopWind.dismiss();
            }
        }
    }
    
    class MyAdapter extends BaseAdapter{

        private List<ItemInfo> mAppList;
        private Context mContext;
        public MyAdapter(Context context,List<ItemInfo> list){
            mContext=context;
            mAppList = list;
        }
        
        @Override
        public int getCount() {
            return mAppList.size();
        }

        @Override
        public Object getItem(int position) {
            return mAppList.get(position);
        }

        @Override
        public long getItemId(int position) {
            return 0;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            ViewHolder viewHolder;
            final ShortcutInfo item = (ShortcutInfo) getItem(position);
            if (convertView == null) {
                viewHolder = new ViewHolder();
                convertView = LayoutInflater.from(mContext).inflate(R.layout.much_draggable_grid_item, null);
                viewHolder.textView = (BubbleTextView)convertView.findViewById(R.id.add_app);
                viewHolder.selectedView = (ImageView)convertView.findViewById(R.id.app_selected);
                convertView.setTag(viewHolder);
            } else {
                viewHolder = (ViewHolder) convertView.getTag();
            }
            
            if(!isAppAddView(item.getIntent())){
                LauncherAppState.getInstance().getIconDecorater().observeIconNeedUpdated(viewHolder.textView, item.getIcon(mIconCache), item.intent.getComponent());
            }
            viewHolder.item = item;
            if(!mAllData.selectList.isEmpty() && mAllData.selectList.contains(item)){
                viewHolder.isSelected = true;
                viewHolder.selectedView.setVisibility(View.VISIBLE);
            }
            viewHolder.textView.setText(item.title);
            viewHolder.textView.setTag(item);
            viewHolder.textView.setTextColor(getResources().getColor(R.color.vpi__background_holo_dark));
            viewHolder.textView.setShadowsEnabled(false);

            return convertView;
        }
        
        public class ViewHolder{
            public BubbleTextView textView;
            public ImageView selectedView;
            public boolean isSelected;
            public ShortcutInfo item;
        }
    }
    
    //add by linmaoqing 2015-11-16
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if(MuchConfig.SUPPORT_MUCH_STYLE && mLauncher.getFloatMenuManager().isFloatMenuOpen()){
            mLauncher.getFloatMenuManager().closeFloatMenu();
            return true;
        }
        return super.onInterceptTouchEvent(ev);
    }
}
